---
layout: default
title: "Data Fetching"
---

# Data Fetching

You can build a react-admin app on top of any API, whether it uses REST, GraphQL, RPC, or even SOAP, regardless of the dialect it uses. This works because react-admin doesn't use `fetch` directly. Instead, it uses a Data Provider object to interface with your API, and [React Query](https://tanstack.com/query/v5/docs/react/overview) to handle data fetching.

## The Data Provider

Whenever react-admin needs to communicate with your APIs, it does so through an object called the `dataProvider`. The `dataProvider` exposes a predefined interface that allows react-admin to query any API in a normalized way.

<img src="./img/data-provider.png" class="no-shadow" alt="Backend agnostic" />

For instance, to query the API for a single record, react-admin calls `dataProvider.getOne()`:

```tsx
const response = await dataProvider.getOne('posts', { id: 123 });
console.log(response.data); // { id: 123, title: "hello, world" }
```

The Data Provider is responsible for transforming these method calls into HTTP requests, and converting the responses into the format expected by react-admin. In technical terms, a Data Provider is an *adapter* for an API.

Thanks to this adapter system, react-admin can communicate with any API. Check out the [list of supported backends](./DataProviderList.md) to pick an open-source package for your API.

You can also [write your own Data Provider](./DataProviderWriting.md) to fit your backend's particularities. Data Providers can use `fetch`, `axios`, `apollo-client`, or any other library to communicate with APIs. The Data Provider is also the ideal place to add custom HTTP headers, authentication, etc.

Check out the [Data Provider Setup](./DataProviders.md) documentation for more details on how to set up a Data Provider in your app.

A Data Provider must implement the following methods:

```jsx
const dataProvider = {
    async getList(resource, { sort, filter, pagination }) => ({ data: Record[], total: number }), 
    async getOne(resource, { id }) => ({ data: Record }),
    async getMany(resource, { ids }) => ({ data: Record[] }),
    async getManyReference(resource, { target, id, sort, filter, pagination }) => ({ data: Record[], total: number }), 
    async create(resource, { data }) => ({ data: Record }),
    async update(resource, { id, data }) => ({ data: Record }),
    async updateMany(resource, { ids, data }) => ({ data: Identifier[] }),
    async delete(resource, { id } ) => ({ data: Record }),
    async deleteMany(resource, { ids }) => ({ data: Identifier[] }),
}
```

**Tip**: A Data Provider can have [additional methods](#adding-custom-methods) beyond these 9. For example, you can add custom methods for non-REST API endpoints, tree structure manipulations, or real-time updates.

The Data Provider is a key part of react-admin's architecture. By standardizing the Data Provider interface, react-admin can offer powerful features, like reference handling, optimistic updates, and autogenerated CRUD components.

## Calling The Data Provider

React-admin uses [TanStack Query](https://tanstack.com/query/latest/docs/framework/react/overview) to call your Data Provider (mostly by leveraging TanStack Query's `useQuery` and `useMutation` hooks). You don't need to know TanStack Query to fetch or update data, as react-admin exposes one hook per Data Provider method:

* [`useGetList`](./useGetList.md)
* [`useGetOne`](./useGetOne.md)
* [`useGetMany`](./useGetMany.md)
* [`useGetManyReference`](./useGetManyReference.md)
* [`useCreate`](./useCreate.md)
* [`useUpdate`](./useUpdate.md)
* [`useUpdateMany`](./useUpdateMany.md)
* [`useDelete`](./useDelete.md)
* [`useDeleteMany`](./useDeleteMany.md)

For instance, to call `dataProvider.getOne()`, use the `useGetOne` hook:

```jsx
import { useGetOne } from 'react-admin';
import { Loading, Error } from './MyComponents';

const UserProfile = ({ userId }) => {
    const { data: user, isPending, error } = useGetOne('users', { id: userId });

    if (isPending) return <Loading />;
    if (error) return <Error />;
    if (!user) return null;

    return (
        <ul>
            <li>Name: {user.name}</li>
            <li>Email: {user.email}</li>
        </ul>
    )
};
```

You can also call the `useDataProvider` hook to access the `dataProvider` directly:

```jsx
import { useDataProvider } from 'react-admin';

const BanUserButton = ({ userId }) => {
    const dataProvider = useDataProvider();
    const handleClick = () => {
        dataProvider.update('users', { id: userId, data: { isBanned: true } });
    };
    return <Button label="Ban user" onClick={handleClick} />;
};
```

Finally, you can use any of TanStack Query's hooks:

- [`useQuery`](https://tanstack.com/query/latest/docs/framework/react/guides/queries) for reading data
- [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) for writing data.

The [Querying the API](./Actions.md) documentation lists all the hooks available for querying the API, as well as the options and return values for each of them.

## Local API Mirror

React-admin caches query data locally in the browser and automatically reuses it to answer future queries whenever possible. By structuring and indexing the data by resource name and ID, React-admin offers several advantages:

- **Stale-While-Revalidate**: React-admin renders the UI immediately using cached data while fetching fresh data from the server in the background. Once the server response arrives, the UI updates with the latest data seamlessly.
- **Data Sharing Between Views**: When navigating from a list view to a show view, React-admin reuses data from the list to render the show view instantly, eliminating the need to wait for the `dataProvider.getOne()` response.
- **Optimistic Updates**: Upon user actions like deleting or updating a record, React-admin immediately updates the local cache to reflect the change, providing instant UI feedback. The server request follows, and if it fails, React-admin reverts the local data and notifies the user.
- **Auto Refresh**: After a successful mutation, React-admin invalidates dependent queries. TanStack Query then refetches the necessary data, ensuring the UI remains up-to-date automatically.

For example, when a user deletes a book in a list, React-admin immediately removes it, making the row disappear. After the API confirms the deletion, React-admin invalidates the list’s cache, refreshes it, and another record appears at the end of the list.

<video controls autoplay playsinline muted loop width="100%">
  <source src="./img/AutoRefresh.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

The local API mirror significantly enhances both the user experience (with a snappy and responsive UI) and the developer experience (by abstracting caching, invalidation, and optimistic updates).

## Mutation Mode

## Custom Data Provider Methods

Your API backend may expose non-CRUD endpoints, e.g., for calling Remote Procedure Calls (RPC).

For instance, let's say your API exposes an endpoint to ban a user based on its `id`:

```
POST /api/user/123/ban
```

The react-admin way to expose these endpoints to the app components is to add a custom method in the `dataProvider`:

```jsx
import simpleRestDataProvider from 'ra-data-simple-rest';

const baseDataProvider = simpleRestDataProvider('http://path.to.my.api/');

export const dataProvider = {
    ...baseDataProvider,
    banUser: (userId) => {
        return fetch(`/api/user/${userId}/ban`, { method: 'POST' })
            .then(response => response.json());
    },
}
```

Then you can use react-query's `useMutation` hook to call the `dataProvider.banUser()` method:

```jsx
import { useDataProvider } from 'react-admin';
import { useMutation } from '@tanstack/react-query';

const BanUserButton = ({ userId }) => {
    const dataProvider = useDataProvider();
    const { mutate, isPending } = useMutation({
        mutationFn: () => dataProvider.banUser(userId)
    });
    return <Button label="Ban" onClick={() => mutate()} disabled={isPending} />;
};
```

Check the [Calling Custom Methods](./Actions.md#calling-custom-methods) documentation for more details.

## Authentication

The `dataProvider` often needs to send an authentication token in API requests. The [`authProvider`](./Authentication.md) manages the authentication process. Here's how the two work together:

1. The user logs in with their email and password
2. React-admin calls `authProvider.login()` with these credentials.
3. The `authProvider` sends the login request to the authentication backend.
4. The backend validates the credentials and returns an authentication token.
5. The `authProvider` stores the token in `localStorage`
6. When making requests, the `dataProvider` reads the token from `localStorage` and adds it to the request headers.

You need to implement the interaction between the `authProvider` and `dataProvider`. Here's an example for the authProvider:

```jsx
// in authProvider.js
const authProvider = {
    async login({ username, password })  {
        const request = new Request('https://mydomain.com/authenticate', {
            method: 'POST',
            body: JSON.stringify({ username, password }),
            headers: new Headers({ 'Content-Type': 'application/json' }),
        });
        let response;
        try {
            response = await fetch(request);
        } catch (_error) {
            throw new Error('Network error');
        }
        if (response.status < 200 || response.status >= 300) {
            throw new Error(response.statusText);
        }
        const { token } = await response.json();
        localStorage.setItem('token', token);
    },
    async logout() {
        localStorage.removeItem('token');
    },
    // ...
};
```

Many Data Providers, like `simpleRestProvider`, support authentication. Here's how you can configure it to include the token:

```js
// in dataProvider.js
import { fetchUtils } from 'react-admin';
import simpleRestProvider from 'ra-data-simple-rest';

const fetchJson = (url, options = {}) => {
    options.user = {
        authenticated: true,
        token: localStorage.getItem('token') // Include the token
    };
    return fetchUtils.fetchJson(url, options);
};
const dataProvider = simpleRestProvider('http://path.to.my.api/', fetchJson);
```

Check your Data Provider's documentation for specific configuration options.

## Relationships

React-admin simplifies working with relational APIs by managing related records at the component level. This means you can leverage [relationship support](./Features.md#relationships) without modifying your Data Provider or API.

For instance, let's imagine an API exposing CRUD endpoints for books and authors:

```
┌──────────────┐       ┌────────────────┐
│ books        │       │ authors        │
│--------------│       │----------------│
│ id           │   ┌───│ id             │
│ author_id    │╾──┘   │ first_name     │
│ title        │       │ last_name      │
│ published_at │       │ date_of_birth  │
└──────────────┘       └────────────────┘
```

The Book show page should display a book title and the name of its author. In a server-side framework, you would issue a SQL query with a JOIN clause. In React-admin, components request only the data they need, and React-admin handles the relationship resolution.

```jsx
const BookShow = () => (
    <Show>
        <SimpleShowLayout>
            <TextField source="id" />
            <TextField source="title" />
            <ReferenceField source="author_id" reference="authors" />
            <TextField source="year" />
        </SimpleShowLayout>
    </Show>
);
```

In the example above, two components call the Data Provider on mount:

- The `Show` component calls `dataProvider.getOne('books')` and receives a book with an `author_id` field
- The `ReferenceField` component reads the current book record and calls `dataProvider.getOne('authors')` using the `author_id` value

This approach improves the developer experience as you don't need to build complex queries for each page. Components remain independent of each other and are easy to compose.

However, this cascade of Data Provider requests can appear inefficient in terms of user-perceived performance. React-admin includes several optimizations to mitigate this:

- **Partial Rendering**: React-admin renders the page with the book data first and updates it when the author data arrives. This ensures users see data as soon as possible.
- **Caching**: If the author data is already cached, React-admin displays it immediately, rendering the entire page in one pass. Since most admin apps are long-lived, the cache is often populated.
- **Local Database Mirror**: React-admin populates its internal cache with individual records fetched using `dataProvider.getList()`. When a user views a specific record, React-admin leverages its internal database to pre-fill the `dataProvider.getOne()` query response. As a result, record details are displayed instantaneously, without any wait time for server responses.
- **Query Aggregation**: React-admin intercepts all calls to `dataProvider.getOne()` for related data when a `<ReferenceField>` is used in a list. It aggregates and deduplicates the requested ids, and issues a single `dataProvider.getMany()` request. This technique effectively addresses the n+1 query problem, reduces server queries, and accelerates list view rendering.
- **Smart Loading Indicators**: `<ReferenceField>` renders blank placeholders during the first second to avoid layout shifts when the response arrives. If the response takes longer, React-admin shows a spinner to indicate progress while maintaining a smooth user experience.
- **Embedded Data** and **Prefetching**: Data providers can return data from related resources in the same response as the requested resource. React-admin uses this feature to avoid additional network requests and to display related data immediately.

Even on complex pages that aggregate data from multiple resources, Reference components optimize API requests, reducing their number while ensuring users quickly see the data they need.

Relationship support in React-admin works out of the box with any API that provides foreign keys. No special configurations are required for your API or Data Provider.

Here is a list of react-admin's [relationship components](./Features.md#relationships):

- [`<ReferenceField>`](./ReferenceField.md)
- [`<ReferenceArrayField>`](./ReferenceArrayField.md)
- [`<ReferenceManyField>`](./ReferenceManyField.md)
- [`<ReferenceManyCount>`](./ReferenceManyCount.md)
- [`<ReferenceManyToManyField>`](./ReferenceManyToManyField.md)
- [`<ReferenceOneField>`](./ReferenceOneField.md)
- [`<ReferenceInput>`](./ReferenceInput.md)
- [`<ReferenceArrayInput>`](./ReferenceArrayInput.md)
- [`<ReferenceManyInput>`](./ReferenceManyInput.md)
- [`<ReferenceManyToManyInput>`](./ReferenceManyToManyInput.md)
- [`<ReferenceOneInput>`](./ReferenceOneInput.md)

If a relationship component doesn't fit your specific use case, you can always use a [custom data provider method](#adding-custom-methods) to fetch the required data.
``

## Real-Time Updates And Locks

Teams where several people work in parallel on a common task need to allow live updates, real-time notifications, and prevent data loss when two editors work on the same resource concurrently. 

<video controls autoplay playsinline muted>
  <source src="./img/CollaborativeDemo.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

React-admin offers powerful realtime features to help you build collaborative applications, based on the Publish / Subscribe (PubSub) pattern. The [Realtime documentation](./Realtime.md) explains how to use them.

These features are part of the [Enterprise Edition](https://react-admin-ee.marmelab.com)<img class="icon" src="./img/premium.svg" />.

### Realtime Data Provider

The realtime features are backend agnostic. Just like for CRUD operations,realtime operations rely on the data provider, using additional methods:

- `dataProvider.subscribe(topic, callback)`
- `dataProvider.unsubscribe(topic, callback)`
- `dataProvider.publish(topic, event)` (optional - publication is often done server-side)

In addition, to support the lock features, the `dataProvider` must implement 4 more methods:

- `dataProvider.lock(resource, { id, identity, meta })`
- `dataProvider.unlock(resource, { id, identity, meta })`
- `dataProvider.getLock(resource, { id, meta })`
- `dataProvider.getLocks(resource, { meta })`

You can implement these features using any realtime backend, including:

- [Mercure](https://mercure.rocks/),
- [API Platform](https://api-platform.com/docs/admin/real-time-mercure/#real-time-updates-with-mercure),
- [supabase](https://supabase.com/),
- [Socket.IO](https://socket.io/),
- [Ably](https://ably.com/),
- and many more.

Check the [Realtime Data Provider documentation](./RealtimeDataProvider.md) for more information, and for helpers to build your own realtime data provider.

### Realtime Hooks And Components

Once your data provider has enabled realtime features, you can use these hooks and components to build realtime applications:

- [`usePublish`](./usePublish.md)
- [`useSubscribe`](./useSubscribe.md)
- [`useSubscribeCallback`](./useSubscribeCallback.md)
- [`useSubscribeToRecord`](./useSubscribeToRecord.md)
- [`useSubscribeToRecordList`](./useSubscribeToRecordList.md)
- [`useLock`](./useLock.md)
- [`useUnlock`](./useUnlock.md)
- [`useGetLock`](./useGetLock.md)
- [`useGetLockLive`](./useGetLockLive.md)
- [`useGetLocks`](./useGetLocks.md)
- [`useGetLocksLive`](./useGetLocksLive.md)
- [`useLockOnMount`](./useLockOnMount.md)
- [`useLockOnCall`](./useLockOnCall.md)
- [`useGetListLive`](./useGetListLive.md)
- [`useGetOneLive`](./useGetOneLive.md)
- [`<ListLive>`](./ListLive.md)
- [`<EditLive>`](./EditLive.md)
- [`<ShowLive>`](./ShowLive.md)
- [`<MenuLive>`](./MenuLive.md)

Refer to the [Realtime documentation](./Realtime.md) for more information.